### **Controllers no NestJS**

------

### **Introdu√ß√£o**

**O que s√£o Controllers?** Controllers s√£o um dos principais componentes do NestJS, respons√°veis por gerenciar as requisi√ß√µes HTTP e enviar respostas adequadas ao cliente. Eles atuam como a interface entre a l√≥gica de neg√≥cios e o mundo externo, organizando e direcionando as intera√ß√µes da aplica√ß√£o com seus usu√°rios.

**Qual o papel dos Controllers em uma aplica√ß√£o?** O principal papel dos controllers √©:

- **Receber e interpretar as requisi√ß√µes** feitas pelos usu√°rios.
- **Validar os dados recebidos**, quando necess√°rio.
- **Delegar a l√≥gica de neg√≥cio** para os servi√ßos ou outras camadas.
- **Responder ao cliente** com os dados ou status adequado.

**De onde veio esse padr√£o?** Controllers s√£o uma implementa√ß√£o do padr√£o **MVC (Model-View-Controller)**, amplamente utilizado em frameworks e aplica√ß√µes web. No NestJS, os controllers assumem a fun√ß√£o de gerenciar as intera√ß√µes com o cliente (equivalente √† "Controller" do MVC), enquanto a "View" pode ser substitu√≠da por respostas JSON no contexto de APIs REST.

**Que problema os Controllers resolvem?** Controllers ajudam a resolver problemas de:

- **Separa√ß√£o de responsabilidades**: Mant√™m a l√≥gica de neg√≥cio isolada em servi√ßos ou outras camadas, evitando c√≥digo "espaguete".
- **Manuten√ß√£o do c√≥digo**: Facilita a leitura, teste e evolu√ß√£o da aplica√ß√£o, especialmente em projetos grandes.
- **Organiza√ß√£o**: Proporcionam um local claro e padronizado para gerenciar rotas e entradas de dados.

------

### **Recursos do NestJS para Controllers**

1. **Decorators:**
   - Os decorators s√£o usados para configurar rotas e tratar requisi√ß√µes HTTP.
   - Eles s√£o declarados sobre os m√©todos e classes para definir a l√≥gica de roteamento e manipula√ß√£o de dados.
2. **Inje√ß√£o de Depend√™ncias:**
   - Controllers podem injetar servi√ßos para delegar a l√≥gica de neg√≥cios, promovendo separa√ß√£o de responsabilidades.
3. **Interceptadores, Pipes, Guards e Filtros de Exce√ß√£o:**
   - Esses recursos podem ser aplicados a controladores ou m√©todos para manipula√ß√£o de dados, seguran√ßa e tratamento de erros.

------

### **Principais Decorators em Controllers**

#### 1. **@Controller()**

- Define uma classe como um controlador.
- Aceita um prefixo opcional para as rotas.

```typescript
@Controller('users') // Todas as rotas ter√£o o prefixo /users
export class UsersController {
  // Define m√©todos que gerenciam requisi√ß√µes HTTP
}
```

#### 2. **@Get()**

- Mapeia uma requisi√ß√£o HTTP GET para o m√©todo.
- Aceita um caminho opcional como argumento.

```typescript
@Get('profile') // Rota: /users/profile
getUserProfile(): string {
  return 'User profile data';
}
```

#### 3. **@Post()**

- Mapeia uma requisi√ß√£o HTTP POST.

```typescript
@Post()
createUser(@Body() userData: CreateUserDto): string {
  return `User ${userData.name} created`;
}
```

#### 4. **@Put()**

- Mapeia uma requisi√ß√£o HTTP PUT.

```typescript
@Put(':id') // Rota: /users/:id
updateUser(@Param('id') id: string, @Body() userData: UpdateUserDto): string {
  return `User ${id} updated`;
}
```

#### 5. **@Delete()**

- Mapeia uma requisi√ß√£o HTTP DELETE.

```typescript
@Delete(':id') // Rota: /users/:id
deleteUser(@Param('id') id: string): string {
  return `User ${id} deleted`;
}
```

#### 6. **@Param()**

- Obt√©m par√¢metros da rota.

```typescript
@Get(':id')
getUserById(@Param('id') id: string): string {
  return `User ID: ${id}`;
}
```

#### 7. **@Query()**

- Obt√©m par√¢metros de consulta (query string).

```typescript
@Get()
getUsers(@Query('role') role: string): string {
  return `Users with role: ${role}`;
}
```

#### 8. **@Body()**

- Obt√©m o corpo da requisi√ß√£o.

```typescript
@Post()
createUser(@Body() userData: CreateUserDto): string {
  return `User ${userData.name} created`;
}
```

#### 9. **@Headers()**

- Obt√©m cabe√ßalhos da requisi√ß√£o.

```typescript
@Get()
getHeaders(@Headers('Authorization') auth: string): string {
  return `Authorization: ${auth}`;
}
```

#### 10. **@Req() e @Res()**

- Acessa objetos de requisi√ß√£o e resposta (usados com modera√ß√£o, pois violam o paradigma de abstra√ß√£o do NestJS).

```typescript
@Get()
getCustomResponse(@Req() req, @Res() res): void {
  res.status(200).send(`Request from: ${req.ip}`);
}
```

------

## **Exemplos Pr√°ticos**

### Exemplo 1: CRUD B√°sico

```typescript
import { Controller, Get, Post, Put, Delete, Param, Body } from '@nestjs/common';

@Controller('users')
export class UsersController {
  @Get()
  getAllUsers(): string {
    return 'List of all users';
  }

  @Get(':id')
  getUserById(@Param('id') id: string): string {
    return `User with ID: ${id}`;
  }

  @Post()
  createUser(@Body() userData: { name: string; age: number }): string {
    return `User ${userData.name} created`;
  }

  @Put(':id')
  updateUser(@Param('id') id: string, @Body() userData: { name: string }): string {
    return `User ${id} updated with name ${userData.name}`;
  }

  @Delete(':id')
  deleteUser(@Param('id') id: string): string {
    return `User ${id} deleted`;
  }
}
```



#### **Explica√ß√£o do Exemplo Pr√°tico 1**

Este exemplo apresenta um controlador chamado `UsersController`, respons√°vel por gerenciar opera√ß√µes CRUD relacionadas a usu√°rios. Ele utiliza v√°rios **decorators** para configurar rotas e extrair informa√ß√µes das requisi√ß√µes HTTP. Vamos detalhar cada parte:

##### **Decorators e suas responsabilidades**

1. **`@Controller('users')`**
   - Define que todas as rotas deste controlador ter√£o o prefixo `/users`.
   - Exemplo: uma requisi√ß√£o para `/users` ser√° gerenciada pelo m√©todo correspondente no controlador.
2. **`@Get()`**
   - Indica que o m√©todo decorado responde a requisi√ß√µes HTTP **GET**.
   - No exemplo:
     - `getAllUsers()` responde a **GET /users** e retorna uma lista de usu√°rios.
     - `getUserById()` responde a **GET /users/:id** e retorna detalhes do usu√°rio com o ID especificado.
3. **`@Post()`**
   - Indica que o m√©todo decorado responde a requisi√ß√µes HTTP **POST**.
   - No exemplo, o m√©todo `createUser()` responde a **POST /users** para criar um novo usu√°rio com os dados fornecidos no corpo da requisi√ß√£o.
4. **`@Put(':id')`**
   - Indica que o m√©todo decorado responde a requisi√ß√µes HTTP **PUT**.
   - O `:id` √© um **par√¢metro de rota**, que ser√° capturado e passado para o m√©todo.
   - No exemplo, `updateUser()` responde a **PUT /users/:id** para atualizar o nome de um usu√°rio com o ID especificado.
5. **`@Delete(':id')`**
   - Indica que o m√©todo decorado responde a requisi√ß√µes HTTP **DELETE**.
   - No exemplo, `deleteUser()` responde a **DELETE /users/:id**, removendo o usu√°rio com o ID especificado.
6. **`@Param('id')`**
   - Extrai o valor do par√¢metro de rota `id` da requisi√ß√£o.
   - No exemplo, √© usado em:
     - `getUserById()` para obter o ID do usu√°rio.
     - `updateUser()` e `deleteUser()` para identificar qual usu√°rio ser√° atualizado ou deletado.
7. **`@Body()`**
   - Extrai o corpo da requisi√ß√£o HTTP.
   - No exemplo:
     - `createUser()` usa o decorator para acessar os dados enviados no corpo da requisi√ß√£o (nome e idade).
     - `updateUser()` usa o corpo da requisi√ß√£o para obter o novo nome do usu√°rio.

------

#### **Fun√ß√µes e suas responsabilidades**

1. **`getAllUsers()`**
   - Retorna uma string indicando a lista de todos os usu√°rios.
   - Simula a recupera√ß√£o de dados de um reposit√≥rio ou servi√ßo.
2. **`getUserById(id: string)`**
   - Recebe um ID como par√¢metro e retorna uma string com informa√ß√µes sobre o usu√°rio correspondente.
   - Simula a busca de um usu√°rio espec√≠fico pelo ID.
3. **`createUser(userData: { name: string; age: number })`**
   - Recebe os dados do usu√°rio pelo corpo da requisi√ß√£o e retorna uma mensagem confirmando a cria√ß√£o do usu√°rio.
   - Simula a l√≥gica de cria√ß√£o de um usu√°rio no sistema.
4. **`updateUser(id: string, userData: { name: string })`**
   - Recebe o ID do usu√°rio e os dados atualizados pelo corpo da requisi√ß√£o.
   - Retorna uma mensagem confirmando a atualiza√ß√£o do nome do usu√°rio com o ID especificado.
5. **`deleteUser(id: string)`**
   - Recebe o ID do usu√°rio como par√¢metro e retorna uma mensagem confirmando a exclus√£o do usu√°rio.
   - Simula a remo√ß√£o de um usu√°rio no sistema.





------

### Exemplo 2: Uso de Query e Headers

```typescript
import { Controller, Get, Query, Headers } from '@nestjs/common';

@Controller('products')
export class ProductsController {
  @Get()
  getProducts(
    @Query('category') category: string,
    @Headers('Authorization') auth: string,
  ): string {
    return `Products in category: ${category}, Auth: ${auth}`;
  }
}
```



#### **Explica√ß√£o do Exemplo Pr√°tico 2**

Este exemplo apresenta um controlador chamado `ProductsController`, que utiliza os **decorators** `@Query()` e `@Headers()` para manipular dados vindos de **query strings** e **cabe√ßalhos HTTP**. Ele exemplifica como lidar com par√¢metros adicionais em requisi√ß√µes HTTP no NestJS.

##### **Decorators e suas responsabilidades**

1. **`@Controller('products')`**
   - Define que todas as rotas deste controlador ter√£o o prefixo `/products`.
   - Exemplo: uma requisi√ß√£o para `/products` ser√° gerenciada pelo m√©todo correspondente no controlador.
2. **`@Get()`**
   - Indica que o m√©todo decorado responde a requisi√ß√µes HTTP **GET**.
   - No exemplo, o m√©todo `getProducts()` responde a **GET /products**, com suporte para par√¢metros de consulta e cabe√ßalhos adicionais.
3. **`@Query('category')`**
   - Extrai o valor do par√¢metro de consulta (`query string`) chamado `category` da requisi√ß√£o.
   - No exemplo:
     - Este par√¢metro √© usado para filtrar produtos por categoria, representando o valor enviado na URL como `/products?category=electronics`.
4. **`@Headers('Authorization')`**
   - Extrai o valor do cabe√ßalho HTTP chamado `Authorization`.
   - No exemplo:
     - Este cabe√ßalho √© usado para capturar informa√ß√µes de autentica√ß√£o ou autoriza√ß√£o enviadas pelo cliente, como tokens ou chaves de API.

------

##### **Fun√ß√£o e suas responsabilidades**

1. `getProducts(category: string, auth: string)`
   - Recebe dois par√¢metros:
     - **`category`**: obtido da query string via `@Query`, representa a categoria de produtos a serem listados.
     - **`auth`**: obtido do cabe√ßalho HTTP via `@Headers`, representa um token ou chave de autoriza√ß√£o.
   - Retorna uma string contendo:
     - O valor da categoria solicitada.
     - O valor do cabe√ßalho `Authorization`.
   - Simula a l√≥gica de recupera√ß√£o de produtos filtrados por categoria e autenticados com base no cabe√ßalho enviado.

------

##### **Fluxo de execu√ß√£o**

1. Um cliente envia uma requisi√ß√£o HTTP GET para a URL `/products?category=electronics`, incluindo um cabe√ßalho `Authorization`.
2. O controlador:
   - Extrai o par√¢metro `category` da query string (`electronics`).
   - Captura o valor do cabe√ßalho `Authorization`.
   - Combina essas informa√ß√µes para formar a resposta.
3. O m√©todo `getProducts()` retorna uma string formatada com as informa√ß√µes obtidas.

------

#### **Exemplo pr√°tico de chamada**

##### **Requisi√ß√£o**

```
GET /products?category=electronics HTTP/1.1
Authorization: Bearer abc123
```

##### **Resposta**

```
Products in category: electronics, Auth: Bearer abc123
```



### **Resumo**

1. **Controllers** s√£o o ponto de entrada para gerenciar requisi√ß√µes no NestJS.
2. Decorators como `@Controller()`, `@Get()`, `@Post()`, e `@Body()` facilitam a defini√ß√£o de rotas e manipula√ß√£o de dados.
4. **Boas pr√°ticas** incluem separar a l√≥gica de neg√≥cios nos servi√ßos e manter os controladores focados na orquestra√ß√£o.

Se precisar de mais detalhes ou refinamento, √© s√≥ avisar! üöÄ